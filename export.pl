#!/usr/bin/perl -w
#
# Download lists for blocking addresses (hosts and networks)
# formatted for Mikrotik RouterOS firewall
# marko(at)saha.se
#
#
use strict;
use warnings;
use Sys::Hostname;
use DBI;
use MCE::Loop;
use MCE::Shared;
sub uniq;
sub checkip;
sub export_ip();
#
# Define settings for database connection, change to whatever you use
my $dsn = "DBI:mysql:DBNAME";
my $username = "DB-USERNAME";
my $password = "PASSWORD";

my $time=scalar localtime();
my $tag=hostname;
# Path to export output file
my $path="PATH TO EXPORT FILE";
# Filename of output file
my $filename="blocklist.rsc";
# text to add to output file formatted for Mikrotik routeros
my $MT_PREFIX="add list=blacklist address=";
my $MT_SUFFIX=" timeout=23:50:00 comment=blocked";
# Make header for output file formatted for Mikrotik routeros
my $header1="# Generated by $tag on $time\n"; 
my $header2="/ip firewall address-list\n"; 
# Variables 
my $ipraw;
my $subnetraw;
my @SUBNET;
my @IPLIST;
my @IPCHECKED;
my %CHKSUBNET;
my %CHKIP;
my @temp;
#
# Whitelisted IP to exclude
# Change to whatever addresses you want. I've excluded the RFC1918 networks and Google, OpenDNS and Cloudflare dns servers
#
my @WHITELIST=("10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "8.8.8.8", "8.8.4.4", "208.67.222.222", "208.67.220.220", "1.1.1.1", "1.0.0.1");
#
print "Start building blocklist\n";
print scalar localtime()."\n";
#
# Get data from database
#
my @addresses = export_ip();
#
# Sort blocks to subnetlist and addresses to iplist
foreach my $var (@addresses) {
	if ( $var =~ /block/) {
		push @SUBNET, ($var =~ m/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}.\d{2})/g);
	}
	elsif ( $var =~ /ip/) {
		push @IPLIST, ($var =~ m/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/g);
	}
	#}
}
#
# Logic to find duplicates and remove whitelisted
#
my @UNIQ_IPLIST = uniq(@IPLIST);
my @UNIQ_SUBNET = uniq(@SUBNET);
foreach my $whiteip (@WHITELIST) {
	@UNIQ_IPLIST = grep {$_ ne $whiteip} @UNIQ_IPLIST;
	@UNIQ_SUBNET = grep {$_ ne $whiteip} @UNIQ_SUBNET;
}

print "Done getting data, compiling list now. This can take some time.... \n";
#
# Check ip-address doesn't exists in ip subnet list, call 
# subroutine in_subnet for the checking, store in @IPCHECKED
# This is time consuming, use as many cores as possible to speed processing. Area for optimisation...
#
#
my $found=0;
MCE::Loop::init {
	max_workers =>'auto', chunk_size =>1
};
@IPCHECKED = mce_loop { my $ipchecked; 
	$ipraw=$_;
	$found=0;
	for my $i (0..$#UNIQ_SUBNET) {
		if ( checkip($ipraw,$UNIQ_SUBNET[$i]) ) {
		$found=1;
		last;
		}			
		if (! $found) {
			$ipchecked = $ipraw;
		}
	}
	MCE->gather($ipchecked);
} @UNIQ_IPLIST;
#
my @IPOUT = uniq(@IPCHECKED);
#
# Print all to file
#
open(my $FH, ">$path$filename") or die "Unable to open file!\n";
print $FH $header1;
print $FH $header2;

for (@IPOUT) {
	chomp;
	print $FH "$MT_PREFIX$_$MT_SUFFIX\n";
}
#
for (@UNIQ_SUBNET) {
	chomp;
	print $FH "$MT_PREFIX"."$_"."$MT_SUFFIX\n";
}
print "Finished compiling blocklist\n";
#
#
#
print scalar localtime()."\n";
exit;
#
# Subroutines
# -----------
#	
# Subroutine uniq
sub uniq {
	my %seen;
	return grep { !$seen{$_}++ } @_;
}
#	
# Subroutine to check if ip-address is in subnet range
# This is done to avoid having both whole subnet as well as an individual ip-address in that subnet in our blocklist
#
sub checkip() {
    my $ip = shift;
    my $block = shift;
    
    my @ip1 = split(/\./, $ip);
    my $ip1 = $ip1[0] * 2**24 + $ip1[1] * 2**16 + $ip1[2] * 2**8 + $ip1[3];
    my @temp = split(/\//, $block);
    
    my $ip2 = $temp[0];
    my $netmask = $temp[1];
    
    my @ip2 = split(/\./, $ip2);
    $ip2 = $ip2[0] * 2**24 + $ip2[1] * 2**16 + $ip2[2] * 2**8 + $ip2[3];
    
    if( $ip1 >> (32-$netmask) == $ip2 >> (32-$netmask) ) {
            return 1;
    }
    return 0;
}
#
# Subroutine for fetching data from mysql
#
sub export_ip() {
        print "Exporting data from database $dsn\n";
        my %attr = ( PrintError=>0,  # turn off error reporting via warn()
             RaiseError=>1);   # turn on error reporting via die()

        my $dbh  = DBI->connect($dsn,$username,$password, \%attr) or die "Error occurred: ",$DBI::errstr;
	# Block with SQL statement
        my $sth = $dbh->prepare("SELECT address_type, address_value FROM adresses WHERE updated >= CURDATE() - INTERVAL
3 DAY");
        $sth->execute() or die $DBI::errstr;
        my @data;
        while ( my ($field1, $field2) = $sth->fetchrow_array() ) {
                push @data, "$field1 $field2";
        }
        $sth->finish();
        return @data;
}

